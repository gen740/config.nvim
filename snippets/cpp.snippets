#==================================================================
#                              Basic
#==================================================================
snippet mainn
	int main()
	{
		${0}
		return 0;
	}

snippet class
	class ${1:class} {
	public:
	  $1() ${2:= default;}
	  virtual ~$1() ${3:= default;}

	private:

	};
	endsnippet

snippet fn
	auto $1($3) -> $2 {
	  $0
	}

snippet incc
	#include <${1:iostream}>

snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${0}
	}

snippet fori "for int i"
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${0}
	}

snippet cout
	std::cout << ${1} << '\n';

#
# snippet for "for"
# for (${1:int} ${2:i} = 0; $2 < ${3:count}; ++$2){
#   $0
# }
# endsnippet
#
# snippet fore "for int i"
# for (int ${1:i} = 1; $1 <= ${2:count}; ++$1){
#   $0
# }
# endsnippet
#
# # iterator
# snippet iter
# 	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
# 		${6}
# 	}
#
# # auto iterator
# snippet itera
# 	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
# 		${3:std::cout << *$1 << std::endl;}
# 	}

#==================================================================
#                              STL
#==================================================================
snippet array
	std::array<${1:T}, ${2:N}> ${3};
snippet vector
	std::vector<${1:T}> ${2};
snippet deque
	std::deque<${1:T}> ${2};
snippet flist
	std::forward_list<${1:T}> ${2};
snippet list
	std::list<${1:T}> ${2};
snippet set
	std::set<${1:T}> ${2};
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
snippet mset
	std::multiset<${1:T}> ${2};
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
snippet uset
	std::unordered_set<${1:T}> ${2};
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
snippet umset
	std::unordered_multiset<${1:T}> ${2};
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
snippet stack
	std::stack<${1:T}> ${2};
snippet queue
	std::queue<${1:T}> ${2};
snippet pqueue
	std::priority_queue<${1:T}> ${2};

#==================================================================
#                              STL
#==================================================================
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});



# # class
# snippet cl
# 	/*! \class $1
# 	 *  \brief ${3:Brief class description}
# 	 *
# 	 *  ${4:Detailed description}
# 	 */
# 	class ${1:`vim_snippets#Filename('$1', 'name')`}
# 	{
# 	public:
# 		$1(${2});
# 		virtual ~$1();
#
# 	protected:
# 		m_${5}; /*!< ${6:Member description} */
# 	};
# # member function implementation
# snippet mfun
# 	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
# 		${0}
# 	}
# # member function implementation without parameters
# snippet dmfun0
# 	/*! \brief ${4:Brief function description here}
# 	 *
# 	 *  ${5:Detailed description}
# 	 *
# 	 * \return ${6:Return parameter description}
# 	 */
# 	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
# 		${0}
# 	}
# # member function implementation with one parameter
# snippet dmfun1
# 	/*! \brief ${6:Brief function description here}
# 	 *
# 	 *  ${7:Detailed description}
# 	 *
# 	 * \param $4 ${8:Parameter description}
# 	 * \return ${9:Return parameter description}
# 	 */
# 	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
# 		${0}
# 	}
# # member function implementation with two parameter
# snippet dmfun2
# 	/*! \brief ${8:Brief function description here}
# 	 *
# 	 *  ${9:Detailed description}
# 	 *
# 	 * \param $4 ${10:Parameter description}
# 	 * \param $6 ${11:Parameter description}
# 	 * \return ${12:Return parameter description}
# 	 */
# 	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
# 		${0}
# 	}
# # namespace
# snippet ns
# 	namespace ${1:`vim_snippets#Filename('', 'my')`} {
# 		${0}
# 	} /* namespace $1 */
# snippet ans
# 	namespace {
# 		${0}
# 	}
# ##
# ## Input/Output
# # std::cin
# snippet cin
# 	std::cin >> ${1};
# ##
# ## Casts
# # static
# snippet sca
# 	static_cast<${1:unsigned}>(${2:expr})${3}
# # dynamic
# snippet dca
# 	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# # reinterpret
# snippet rca
# 	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# # const
# snippet cca
# 	const_cast<${1:unsigned}>(${2:expr})${3}
# ## Iteration
# # for i
# snippet fori
# 	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
# 		${4}
# 	}
#
# # foreach
# snippet fore
# 	for (${1:auto} ${2:i} : ${3:container}) {
# 		${4}
# 	}
# # iterator
# snippet iter
# 	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
# 		${6}
# 	}
#
# # auto iterator
# snippet itera
# 	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
# 		${3:std::cout << *$1 << std::endl;}
# 	}
# ##
# ## Lambdas
# # lamda (one line)
# snippet ld
# 	[${1}](${2}){${3}};
# # lambda (multi-line)
# snippet lld
# 	[${1}](${2}){
# 		${3}
# 	};
# # snippets exception
# snippet try
# 	try {
#
# 	}catch(${1}) {
#
# 	}
# # auto function
# snippet af auto function
# 	auto ${1:name}(${2}) -> ${3:void}
# 	{
# 		${0}
# 	};
# # Range-v3 transform
# snippet transform "ranges::views::transform"
# 	${1:${2:std::}${3:ranges::}views::}transform($4)
# # Range-v3 transform
# snippet filter "ranges::views::filter"
# 	${1:${2:std::}${3:ranges::}views::}filter($4)
# # Range-v3 ranges::
# snippet r "ranges::"
# 	ranges::
# # Range-v3 ranges::views::
# snippet rv "ranges::views::"
# 	ranges::views::
# # Range-v3 ranges::actions::
# snippet ra "ranges::actions::"
# 	ranges::actions::
# # STL std::ranges::
# snippet sr "std::ranges::"
# 	std::ranges::
# # STL std::views::
# snippet sv "std::views::"
# 	std::views::


#
# snippet inc "#include <>"
# #include <$1
# $0
# endsnippet
#
# snippet mainn "main ()"
# int main() {
# 	$0
# 	return 0;
# }
# endsnippet
#
# snippet "(\w+)\.f" "postfix function" r
# auto `!p snip.rv = match.group(1)`($1) -> $2 {
# 	$3
# }
# $0
# endsnippet
#
# snippet ce "constexpr"
# constexpr $1
# endsnippet
#
# snippet sc "static constexpr"
# static constexpr $1
# endsnippet
#
# snippet st "struct"
# struct $1 {
# 	$2
# };
# $0
# endsnippet
#
# snippet ts "template struct"
# template <class ${1:T}>
# struct $2 {
# 	$3
# };
# $0
# endsnippet
#
# snippet tts "template struct"
# template <class ${1:T}, class ${2:U}>
# struct $3 {
# 	$4
# };
# $0
# endsnippet
#
#
# snippet tc "template class"
# template <class ${1:T}>
# class $2 {
# 	$3
# };
# $0
# endsnippet
#
# snippet ttc "template class"
# template <class ${1:T}, class ${2:U}>
# class $3 {
# 	$4
# };
# $0
# endsnippet
#
# snippet tp "template"
# template <class ${1:T}>
# $0
# endsnippet
#
# snippet ttp "template"
# template <class ${1:T}, class ${2:U}>
# $0
# endsnippet
#
# snippet "(\w+)\.cl" "postfix function" r
# class `!p snip.rv = match.group(1)` {
# public:
#   `!p snip.rv = match.group(1)`() ${1:= default;}
#   virtual ~`!p snip.rv = match.group(1)`() ${2:= default;}
#
# private:
#   /* data */
# };
# endsnippet
#

# vim: set sts=4 sw=4 ts=4 noet:
